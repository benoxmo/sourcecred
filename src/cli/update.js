// @flow
// Implementation of `sourcecred update`

import dedent from "../util/dedent";
import {LoggingTaskReporter} from "../util/taskReporter";
import type {Command} from "./command";
import * as Common from "./common";
import {defaultWeights, fromJSON as weightsFromJSON} from "../analysis/weights";
import {projectFromJSON} from "../core/project";
import {load, type LoadOptions} from "../api/load";
import fs from "fs-extra";
import path from "path";
import {partialParams} from "../analysis/timeline/params";
import {type PluginDeclaration} from "../analysis/pluginDeclaration";
import {declaration as discourseDeclaration} from "../plugins/discourse/declaration";
import {declaration as githubDeclaration} from "../plugins/github/declaration";
import {declaration as identityDeclaration} from "../plugins/identity/declaration";

function usage(print: (string) => void): void {
  print(
    dedent`\
    usage: sourcecred update
           sourcecred update --help

    Updates the cred for the given cred instance.

    Must be run from within a SourceCred instance (i.e. a sourcecred.json file
    should be present at root). Running this command will:
    - generate a cache directory (if not already present), and use that
      cache (if present). If called with the --replace-cache command,
      any existing cache will be erased and regenerated.
    - generate a data directory (if not already present), and populate it
      with a cred graph and scores file

    The sourcecred.json file must be a SourceCred project specification, as
    generated by running sourcecred init

    Arguments:
        --help
            Show this help message and exit, as 'sourcecred help update'.

    Environment variables:
        SOURCECRED_GITHUB_TOKEN
            API token for GitHub. This should be a 40-character hex
            string. Required if using the GitHub plugin; ignored
            otherwise.

            To generate a token, create a "Personal access token" at
            <https://github.com/settings/tokens>. When loading data for
            public repositories, no special permissions are required.
            For private repositories, the 'repo' scope is required.
    `.trimRight()
  );
}

function die(std, message) {
  std.err("fatal: " + message);
  std.err("fatal: run 'sourcecred help update' for help");
  return 1;
}

const updateCommand: Command = async (args, std) => {
  for (let i = 0; i < args.length; i++) {
    switch (args[i]) {
      case "--help": {
        usage(std.out);
        return 0;
      }
      default: {
        return die(std, `unexpected argument: ${args[i]}`);
      }
    }
  }

  const cwd = process.cwd();

  const projectFilePath = path.join(cwd, "sourcecred.json");
  if (!(await fs.exists(projectFilePath))) {
    return die(
      std,
      `no sourcecred.json file found. Please run sourcecred init first.`
    );
  }
  const project = await loadProject(projectFilePath);

  const weightsFilePath = path.join(cwd, "weights.json");
  const weights = await loadWeightsOrDefaults(weightsFilePath);

  const githubToken = Common.githubToken();

  const taskReporter = new LoggingTaskReporter();
  const plugins: PluginDeclaration[] = [];
  if (project.discourseServer != null) {
    plugins.push(discourseDeclaration);
  }
  if (project.repoIds.length) {
    plugins.push(githubDeclaration);
    if (githubToken == null) {
      return die(
        std,
        "attempting to load GitHub, but SOURCECRED_GITHUB_TOKEN not set"
      );
    }
  }
  if (project.identities.length) {
    plugins.push(identityDeclaration);
  }

  const params = partialParams({weights});
  const options: LoadOptions = {
    project,
    params,
    plugins,
    sourcecredDirectory: cwd,
    githubToken,
  };
  await load(options, taskReporter);
  return 0;
};

const loadProject = async (path: string) => {
  if (!(await fs.exists(path))) {
    throw new Error(`Project path ${path} does not exist`);
  }

  const raw = await fs.readFile(path, "utf-8");
  const json = JSON.parse(raw);
  try {
    return projectFromJSON(json);
  } catch (e) {
    throw new Error(`project at path ${path} is invalid:\n${e}`);
  }
};

const loadWeightsOrDefaults = async (path: string) => {
  if (!(await fs.exists(path))) {
    return defaultWeights();
  }

  const raw = await fs.readFile(path, "utf-8");
  const weightsJSON = JSON.parse(raw);
  try {
    return weightsFromJSON(weightsJSON);
  } catch (e) {
    throw new Error(`provided weights file is invalid:\n${e}`);
  }
};

export const help: Command = async (args, std) => {
  if (args.length === 0) {
    usage(std.out);
    return 0;
  } else {
    usage(std.err);
    return 1;
  }
};

export default updateCommand;
